#include "Dri_1Wire.h"

//函数功能声明
/**
 * @brief 初始化功能
 * 
 * @return bit 从设备的响应信号
 */
bit Dri_1Wire_Init()
{
    bit result;
    //1.主设备发送复位脉冲 [要发送指令的开始]
    DQ = 0;
    //2. 让DQ的值延时480us
    Delay480us();
    //3. 主设备释放DQ的控制权 
    DQ = 1;
    //4. 为了让DQ线的值确定是1 , 给延时 [15-60us] 
    Delay60us();
    //5. DQ的控制权已经给从设备了,主设备需要接收从设备相应的确认信号
    result = DQ;

    //? . 需不需要释放DQ  -> 大概率不需要 : 因为接下来DQ的操作权又回到主设备手中
    // Delay60us();
    // DQ = 1;
    //6. 至少延时420us
    Delay480us();
    return result; //返回从设备的确认信号
}
/**
 * @brief 向从设备写入一个字节数据
 * 
 * @param byte 要写入的字节数据
 */
void Dri_1Wire_WriteByte(u8 by) //10101010
{
    //因为形参是byte类型,1wire协议每次发送一位数据,从低位发,所以需要循环拆解byte
    u8 i;

    for (i = 0; i < 8; i++)
    {
        //1. 先拉低DQ
        DQ = 0;

        //2. 让DQ保持10us时间
        Delay10us();

        //3. 把要写的数据赋值给DQ
        // DQ = by; //C语言语法 : 当把一个多位数据赋值给一个1位变量, 多位数据会被当做一个boolean值 [错误的写法]
        DQ = by & 0x01; //让by的最低位保持不变,其他位置为0,再赋值给DQ [by最低位赋值完毕]
        by >>= 1; //剔除by刚刚赋值过的最低位

        //DQ = 0 , by -> 01010101
        //DQ = 1 , by -> 00101010
        //DQ = 0 , by -> 00010101
        // ...
        //DQ = 1 , by -> 00000000


        //4. 让DQ的信号至少保持45us时间
        Delay60us(); //这个60us时间是给从设备去采样的

        //4. 主设备释放DQ 
        DQ = 1;
    }
    
}


/**
 * @brief 从 从设备 读取一个字节数据
 * 
 * @return u8 读到的一个字节数据
 */
u8 Dri_1Wire_ReadByte() //从设备 : 1010 1010
{
    //定义一个变量 依次接收从设备发来的数据
    u8 by = 0;

    u8 i;

    //准备中间变量
    u8 temp = 0;

    //1Wire协议每次发都是发1位数据,从低位开始发
    for (i = 0; i < 8; i++)
    {
        //1. 拉低DQ [主设备发起复位脉冲]
        DQ = 0;
        //2. 拉高DQ [主设备释放DQ]
        DQ = 1;
        //3. 延时10us, 让从设备设置DQ的值
        Delay10us();
        //4. 主设备采样
        //by = DQ; 错误
        /*
            1010 1010
            第一次循环 i = 0 : temp = DQ(0); temp = 00000000 ; temp <<= 0 (00000000); by = 00000000;
            第二次循环 i = 1 : temp = DQ(1); temp = 00000001 ; temp <<= 1 (00000010); by = 00000010;
            第三次循环 i = 2 : temp = DQ(0); temp = 00000000 ; temp <<= 2 (00000000); by = 00000010;
            第四次循环 i = 3 : temp = DQ(1); temp = 00000001 ; temp <<= 3 (00001000); by = 00001010;
            第五次循环 i = 4 : temp = DQ(0); temp = 00000000 ; temp <<= 4 (00000000); by = 00001010;
            第六次循环 i = 5 : temp = DQ(1); temp = 00000001 ; temp <<= 5 (00100000); by = 00101010;
            第七次循环 i = 6 : temp = DQ(0); temp = 00000000 ; temp <<= 6 (00000000); by = 00101010;
            第八次循环 i = 7 : temp = DQ(1); temp = 00000001 ; temp <<= 7 (10000000); by = 10101010;
        */
        temp = DQ;  
        temp <<= i;
        by |= temp;

        //5. 接收过程需要时间 -> [57->58us]
        Delay60us(); //如果时间多了,就把延时函数改成延时50us的

        //6. 读完数据后都需要把DQ拉高
        DQ = 1;
    }

    //返回by的值
    return by;
}
