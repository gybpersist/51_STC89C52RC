#include "Com\Com_Util.h"

void main()
{
    //1. 启动定时器0
    //1.1 中断总开关打开
    EA = 1;
    //1.2 定时器0的开关打开
    ET0 = 1;

    //2. 选择定时器脉冲来源[C/T#]和工作模式[M0,M1] -> 寄存器TMOD中设置[不可以位寻址]
    //2.1需要把TMOD的低三位设置为 0 ,其他位保持不变   [GATE,C/T#,M1,M0] -> [0,0,0,1]
    //逻辑 : TMOD &= 0xF0 [11110000]
    TMOD &= 0xF0;
    //2.2需要把0[C/T#:使用单片机内部时钟]01[工作模式 : 16位脉冲计数器]赋值给TMOD的低三位
    //逻辑 : TMOD |= 0000 0001 
    TMOD |= 0x01;

    //3. 计算脉冲计数器的初始值 65536 - 0.001 / (12 / 11059200) = 64614
    // 需要把整个初始值给 TL0 [存低8位] 和 TH0[高8位] 这两个脉冲计数器寄存器 
    //从64614 -> 65536 计数耗时 1ms --> 1毫秒触发一次 定时器中断
    //如何把64614的二进制数值分别赋值给TL0和TH0 [64614的二进制数值 : 1111 1100 0110 0110]
    TL0 = 64614;
    TH0 = 64614 >> 8;

    //4.设置定时器中断优先级 [省略 : 因为现在的中断只有一个定时器0的中断,所以省略设置优先级]

    //5. 启动脉冲计数器（开始计数）
    //当GATE=0时，外部引脚（INT0，P3.2）无效，此时只能由内部寄存器TR0控制，当TR0=1时，脉冲计数器开始计数，TR0=0时，停止计数。
    //让GATE是 0 [TMOD寄存器中] , TR0 = 1
    TR0 = 1;
    //防止程序跑飞
    while(1);
}

//6. 编写中断服务程序 
void Timer0_Handler() interrupt 1
{
    //一秒亮灭一次LED0
    //我们的定时器中断 1ms触发一次 -> 触发1000次才改变一次LED的状态
    static u16 count = 1000;

    //因为定时器中断触发条件是 溢出时触发定时器中断 -> 当我需要多次触发时,需要手动重置脉冲计数器的初始化值
    TL0 = 64614;
    TH0 = 64614 >> 8;

    //不用循环,因为定时器中断每中断一次调用一次这个函数
    if (count == 0)
    {
        P00 = ~P00;
        //当count为0了,为了能让其重新计数 所以把count的值回复1000
        count = 1000;
    }

    //count自减
    count--;
    
}